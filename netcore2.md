# usefull CLI commands
switch to TodoServices.Domain
Add-Migration Initial -context SqlDbContext -StartupProject TodoServices.Command -OutputDir Migrations

We have to manually create postgres DB:
createdb --encoding=utf-8 --owner=myapi netcore2



# Фабула:
Даний проект це реалізація примітивного Туду менеджера, що дозволяє наступним чином працювати з задачами:
- створювати нові
- редагувати, тільки не завершені
- видаляти, тільки не завершені
- завершувати , тільки не завершені
- переглядати список задач, з вибіркою по даті створення та ким виконано

## Організація рішення:
- Сервер авторизації - Identity
- Фронтенд - MVC
- шаблон CQRS - сервіси Read, Command, Message
- шина даних (на прикладі RabbitMQ + EasyNetQ)
- Урли, провайдери БД та обмеження сервера авторизації можна отримати з констант збірки Shared.Enum
- Проекти Shared поділені по призначенню, що зрозумілі з назви
- Shared.Common - містить всі батьківські типи даних рішення та реалізацію UnitOfWork

### Базові типи даних
Всі типи даних наслідуються від основних: що прийняті в рішенні, а саме:
- команди, ICommand
- події, BusEvent
- dto, DtoModel
- domain model, DomainModel
- виключення

### Особливості логування
Використання Serilog дозволяє замінити штатний логер та додати в конвейєр обробки різні "напрямки" виводу інформації, в консоль, в файл, в ажур лог і тп
Стратегію логування передбачає наступне:
- обов'язкове логування рівня Debug для фіксації проходження будь-яких системних операцій
- обов'язкове логування рівня Error/Fatal в конструкціях try/catch/finally
- обов'язкове логування разових системних операцій рівня Infoб що дають уявлення про роботу сревісів, наприклад: успішний запуск сервісу


## Організація фронтенду:
- Є власні TagHelpers, полегшують роботу з Razor
- Є локалізація за допомогою PO файлів, локалізація використовується виключно на Frontend, основна мова English
- Є логування за допомогою Serilog, налаштування в appsettings.json
- Є взаємодія з серверром Авторизації
- Є взаємодія з API сервісами 
- Є використання bower компонентів: Bootstrap, FontAwesome, Jquery, popper, bootstrapdatepicker
- Є збірка скриптів та стилів за допомогою gulp (приклад тут)[* https://itchief.ru/bootstrap/build-project-with-gulp-v4]
- ViewModel повністю повторюють організаційну структуру View 
- Для відображення випадаючих списків ЗАВЖДИ використовуємо встроєний тип даних SelectListItem

### Робота з сервісами RestAPI
- Для інстанції HttpClient реалізовано шаблон фабрики, код ізольовано у збірці SharedHttpClient
- Всі відповіді від сервісів серіалазуються в тип ParsedResponse
- Базовий контроллер містить код обробки ParsedResponse
- Базовий контроллер містить код отримання токену з сервера авторизацї, у тому числі з контексту авторизованого користувача

### Особливості Localization
- реалізовано фільтр Middleware (Shared.Middleware.Localization) для вказання локалізації в Url
- задача відображення вірних текстів повністю реалізовується виключно на Frontend, це не задача Rest сервісів
- використання PO файлів унеможливлює, на момент написання, використання локалізації на рівні ViewModel, є спосіб обійти це використовуючи  локалізацію текстів на View, при цьому потрібно вручну підготувати всі теги data-*, що потрібні для клінтської валідації, тобто не використовувати tag helper типу asp-for, див Create.cshtml, Edit.cshtml

### TagHelpers
Основна причина створення - зменшення спагетті-коду в Razor view, додано наступні Tag-helper:
- Checked, Selected, відмічають обрані елементи
- DayFromTo, відображає період часу в текстовому виді з - по
- DM, DMY, відображають дати у заданому форматі
- Hide, приховує весь тег згідно умови
- Money, відображає гроші у заданому форматі
- PageFooterб футер сторінки
- PageTitle, заголовок сторінки
- Select, відображає html tag select

## Організація сервісів
- Всі сервіси підтримують версії, в хедері "api-version" та в строці запиту.
- Сервіси, що прцюють з БД, підтримують роботу з кількома провайдерами, використовують активний з appsettings.json
- Сервіси обробляють тільки відомі типи виключень, наприклад: Shared.Common.Exceptions
- Контроллери містять виключно логіку, що стосуються ViewModel, логування, обробки відомих виключень, що генерує шар логіки App. Логіку виокремлено в окремий клас, наприклад CommandHandler, ReadLogic
- Сервіси мають виокремлені спільні збірки, що містять DTO та Events, наприклад: TodoServices.Shared
- Сервіс Команд містить власну модель команд, з якою працює App логіка, це інший рівень абстракції відокремлений від команд Dto. Див уважніше на шаблон іменування класів!!!
- Початкове наповнення бд даними реалізовано в сервісі команд

### Обробка подій та робота з чергами
- В рішенні використно RabbitMQ + EasyNetQ для спрощення налаштування та роботи
- Робота з шиною абстрагована в окрему збірку Shared.Queue, що дозволяє залежним проектам не посилатися на провайдерів шин
- Робота з чергами організована за допомогою шаблону Publish/Subsribe
- Сервіси, що працюють з чергами використовувати шаблон сінглтон клієнта шини
- Сервіси, що реалізують Publisher використовують провайдер за потреби
- Сервіси, що реалізують Subsriber реалізують статичний клас з підписками та посиланням на сінглтон клієнта шини



## Організація роботи з БД:
- ORM - EntityFramework
- Є базовий SqlDbContext від якого наслідуються всі інші для наслідування моделі БД та обробки специфіки кожного з провайдерів, наприклад типів даних.
- Організована робота з кількома провайдерами, кожен додатковий виділений у свою збірку зі своїми міграціями, наприклад: TodoServices.Domain.Postgres
- Міграції та створення БД закріплено за сервісом команд, TodoServices.Command
- Зачитування даних відбувається з використання трансформації доменної моделі в проміжну, з метою відмови від перевірки версій об'єктів та кешування на рівні ORM
- Для операцій модифікації даних реалізовано шаблон UnitOfWork

## Налаштування Nuget feed та використання пакетів
- Для налаштування Nuget фіду потрібно виконати наступні кроки вказані за посиланням https://docs.microsoft.com/en-us/vsts/package/get-started-nuget?view=vsts
- Після створення фіду потрібно підключити його до vsts build, який буде публіковати пакети до фіду
- Для цього потрібно додати task`и dotnet з командою pack та push

## Використання EnergySuiteFeed
- Створено фід для поточного репозиторію з назвою EnergySuiteFeed.
- Для використання EnergySuiteFeed потрібно додати новий package source до Nuget вказавши в полі Source посилання https://energysuite.pkgs.visualstudio.com/_packaging/EnergySuiteFeed/nuget/v3/index.json



# Наступні кроки
- реалізувати збереження даних користувацького вводу в IndexDb
- реалізація автоматичної підписки на події, завдяки реалізації IHandler, заготовка знаходиться в Shared.Util.EventHandlerDiscovery
- реалізація відмовостійкої роботи за допомогою Polly
- реалізувати парадигму PWA, додати сервіс, зберігати результати викликів REST API в IndexDb
- реалізація кешування основної інформації в пам'яті, заміна статичного MessageLogic.TodoStates на щось більш розумне, наприклад Redis (можливі сценарії: сервіс розрахунків, що визначає баланс по особовому рахунку; сервіс, що дає кількість доступних для замовлення товарів)
